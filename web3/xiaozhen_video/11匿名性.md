BTC中不要求使用真实姓名，但不是说完全没有名字，而是使用化名pseudonymity。

如果银行允许使用化名，那么其匿名性要强于BTC。因为BTC的账本是公开的，而银行的账本是受控制的。

# 破坏BTC匿名性
## 多账户关联
一个用户可以生成多个BTC账户，但进行交易时，容易被人用多输入，以及找零输出账户来进行关联分析。

## 与现实身份的关联
当和现实世界发生关联时，例如兑换法币，资金转入转出，使用BTC购物支付，需要填写收货地址，或者当面支付时。这些场景都会导致BTC账户和真实身份建立联系，导致隐私泄漏。同时如果和上一点多账户关联相联系，可能会导致很多账户的隐私泄漏。

# 提高匿名性的方法

## 网络层
多路径转发（TOR洋葱路由）

## 应用层
将不同来源的币混在一起coin mixing。
但目前没有信誉度很高的coin mixing服务，因为有卷款跑路风险。

一些在线钱包也有coin mixing的性质，但不保证一定履行。

交易所天然有coin mixing的作用，交易的过程中会涉及多次法币与虚拟货币的转换。但是前提是交易所不会泄漏相关的记录，如提币，存币。

# 零知识证明
零知识证明是指一方（证明者）向另一方（验证者）证明一个陈述时正确的，而无需透露除该陈述是正确的外的任何信息。

BTC相关的一个场景是证明某个BTC账户是某人的。这个过程实际上是证明这个人知道某个私钥，此时可以通过签名验证的方式，通过发送经过私钥加密的签名，让对方通过公钥解密，就可以知道是否验证成功。
本例是否是零知识证明有争议，因为透露了签名。

# 同态隐藏
零知识证明的数学基础是同态隐藏，它具有三个性质：

- 如果x,y不同，那么他们的加密函数值E(x)和E(y)也不相同。
- 给定E(x)的值，很难反推出x的值。
- 给定E(x)和E(y)的值，我们可以很容易地计算出某些关于x,y的加密函数值。
    - 同态加法：通过E(x)和E(y)计算出E(x+y)的值
    - 同态乘法：通过E(x)和E(y)计算出E(xy)的值
    - 扩展到多项式

第一个性质指的是不会发生碰撞，同时也反过来说明如果E(x)和E(y)相同，则x和y也相同。
第二个性质说明加密函数不可逆，知道结果无法推出输出。和BTC中使用的密码学hash函数类似。
第三个性质指的是同态运算，说的是对于加密后的函数值，进行某些代数运算，等价于先进行代数运算，然后再加密。

## 例子1
Alice想要向Bob证明她知道一组数x和y，使得x+y=7，同时不让Bob知道x和y的具体数值。

证明方法：
1. Alice把E(x)和E(y)的数值发给Bob
2. Bob通过收到的E(x)和E(y)计算出E(x+y)的值（利用性质三同态运算）
3. Bob同时计算E(7)的值，如果E(x+y)=E(7)，那么验证通过，否则验证失败

## 例子2-盲签方法

- 用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款
- 用户A把SerialNum和Token交给B完成交易
- 用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款
- 银行无法把A和B联系起来
- 中心化

老师举的这个例子，可以完善一下：
1. 用户A的货币有一个编号SerialNum，并自己生成盲化因子，用户A先对货币SerialNum进行盲化处理，得到盲化信息Info
2. 用户A将盲化后的信息Info提供给银行，银行使用私钥对其进行签名，得到Token。同时从A扣款
3. 用户A使用盲化因子，解盲签名，然后将货币SerialNum，以及解盲后的银行签名Token提供给用户B
4. 用户B使用银行的公钥解密token，验证交易正确性，然后将货币SerialNum，以及银行签名，提交给银行，进行验证
5. 银行验证通过，则记录下来货币SerialNum的当前状态，并增加B的存款
6. 银行并不知道B拿来的SerialNum来源是哪里，所以无法得知是A给B的转账

这里的老师没有提到的是第三步中的解盲签名

## 例子3-零币和零钞
在协议层就融入了匿名化处理，其匿名属性来自密码学保证。
- 零币，系统中存在基础币（例如BTC）和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联。花的时候，只要通过零知识证明，证实花的币是区块链系统中存在的可花的币即可。原理类似于混币服务。
- 零钞，不依赖于任何基础币，区块链中之记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址，也不显示交易金额，所有交易通过零知识验证的方式进行。

零币和零钞由于各种限制（数学原理，性能等），并不是主流。而且由于存在和现实世界的交流，所以还是无法做到100%匿名安全。